
<!---

Whoa! What are you doing here? Don't you know that academic code is
dangerous, ugly, and harmful to your health? Surely, some cats do it
right, but the beauty of this website (why thank you!) is only skin
deep (I promise).

If you're looking for our javascript code, the good stuff is in calculate-examples.js.

The rest is pretty nasty.

-->

<head>

  <script language="JavaScript" type="text/javascript" src="flotr-0.1.0alpha.js"></script>
  <script language="JavaScript" type="text/javascript" src="calculate-misc.js"></script>
  <script language="JavaScript" type="text/javascript" src="calculate-examples.js"></script>
  <link href="jquery-ui.css" rel="stylesheet" type="text/css"/>
  <script language="JavaScript" type="text/javascript" src="jquery-1.6.2.min.js"></script>
  <script language="JavaScript" type="text/javascript" src="jquery-ui-1.8.16.custom.min.js"></script>
  <script language="JavaScript" type="text/javascript" src="prototype-1.6.0.2.js"></script>
</script>

 <script>
     jQuery.noConflict();
 </script>



<title>Probabilistically Bounded Staleness</title>
<link rel=StyleSheet href="bootstrap.min.css" type="text/css">
<link rel=StyleSheet href="consistency.css" type="text/css">

<script type="text/javascript"> var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-27366179-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();</script>

</head>

<body>

    <header class="jumbotron masthead" id="overview">
      <div class="inner">
        <div class="container">
          <h1>PBS: Probabilistically Bounded Staleness</h1>
          <p class="lead">
	    How eventual is eventual consistency? How consistent is
	    eventual consistency?<br />  PBS provides answers to these
	    questions using new techniques and simple modeling.<br />  Find
	    out how and play with models in your browser on this
	    page.<br />
        </div><!-- /container -->
      </div>
    </header>

    <div class="topbar">
      <div class="fill">
        <div class="container">
          <a class="brand" href="#">PBS: Probabilistically Bounded Staleness</a>
          <ul class="nav">
            <li><a href="#about">About</a></li>
            <li><a href="#instructions">Instructions</a></li>
            <li><a href="#demo">Demo</a></li>
            <li><a href="#questions">Questions</a></li>
            <li><a href="#moreinfo">More Info</a></li>
            <li><a href="#thanks">Thanks</a></li>
          </ul>
        </div>
      </div>
    </div>


<div class="container">
<div class="content">

<section id="about">

<div class="page-header"> <h1>PBS in Brief <small>  What is PBS and why should you care?</small></h1></div>


<blockquote>
    <p>"All good ideas arrive by chance."</p>
    <small>Max Ernst</small>
</blockquote>

<p>Eventually consistent semantics provide almost no guarantees
regarding the recency of data returned (unbounded staleness of
versions).  However, we can predict the expected consistency of an
eventually consistent data store using models that we call
Probabilistically Bounded Staleness.  In practice, and in the average
case, eventually consistent data stores often deliver consistent data.
Using PBS predictions, we can optimize the
<a href="http://dbmsmusings.blogspot.com/2011/12/replication-and-latency-consistency.html">trade-off
between latency and consistency</a> and better understand why so many
data store users opt for eventual consistency. </p>

<p>If you're a savvy reader or an academic, you're better off reading 
our (fairly readable) <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-4.pdf">technical report</a>.  If
you're bored, skip to our cool <a href="#demo">demo</a>.</p>

If you don't know what eventual consistency means, <a href="#" id="ecbackground-toggle">click here</a>.

<div id="ecbackground" style="display:none;">
<h3> An Overview of Eventual Consistency </h3>

<p>
People today
use <a href="http://en.wikipedia.org/wiki/Distributed_database">distributed
databases</a> for many reasons.  People replicate for fault tolerance:
if the data store is replicated across multiple computers, they won't
lose data when one fails.  Similarly, if one computer crashes, the
others can still serve requests.  People replicate for capacity: at
scale, one node may not be able to fulfill all requests due to
limitations like network bandwidth, disk bandwidth, or processing
capability.
</p>

<p>
Distributing data stores sounds great--until you start worrying about
maintaining the contents of each <em>replica</em>.  When you consider
the <a href="http://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a>, which says
that you can have two of consistency (all replicas agree on the same
value), availability (you can always get an answer from a replica),
and partition tolerance (the system works even if replicas can't
talk), things get hairy.  There are a number of distributed data stores
designs that address the CAP theorem, and many sacrifice consistency
for availability and fault tolerance.
</p>

<p>
Many of these data stores are
<a href="http://en.wikipedia.org/wiki/Eventual_consistency">eventually
consistent</a>.  Eventually consistent data stores make no guarantees
as to the recency of data that they return.  They promise
that <em>eventually</em>, in the absence of new writes, all replicas
that are responsible for a data item will agree on the same version.
How eventual is eventual?  How old is the data returned? Until now,
there were no good answers to these questions.
</p>

<p>Eventual consistency
is <a href="http://dbmsmusings.blogspot.com/2011/12/replication-and-latency-consistency.html">also
useful</a> because, by contacting fewer replicas, read and write
operations complete more quickly, lowering latency.  This
latency-consistency trade-off is not well-understood yet is frequently
chosen in practice (by Cassandra by default and many operators in the
wild)--see Section 2.3 of
our <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-4.pdf">technical
report</a>.
</p>
</div>

<h3> Probabilistically Bounded Staleness </h3>

<p>
Data stores aren't black boxes.  We know how they're built, and,
accordingly, should be able to predict how they operate in practice.
While eventually consistent data stores make no <em>guarantees</em>
about the recency of data they return, we can model their operation to
predict what consistency they provide.  We call this Probabilistically
Bounded Staleness, or PBS.
</p>

<p>PBS models staleness according to two metrics: versions and time.
<ul>
<li><b>PBS <it>t</it>-visibility</b> models the probability that we will read a value <it>t</it> seconds after its write completes.  This answers the question: how eventual is eventual consistency?</li>
<li><b>PBS <it>k</it>-staleness</b> models the probability that we will read a value that is no more than <it>k</it> versions older than the last written version.  This answer the question: how consistent is eventual consistency?</li>
<li><b>PBS <<it>k,t</it>>-staleness</b> combines these two metrics and models the probability that we will read a value that is no more than <it>k</it> versions older than the last written version if we wait <it>t</it> seconds after the last version was written.
</ul>

<p>
These metrics are expectations, not guarantees.  However, as we
will <a href="#demo">see</a>, eventual consistency is often
consistent.
</p>

Interested in more detail? <a href="#" id="gorydetail-toggle">Click here</a>
or read our <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-4.pdf">technical report</a>.

<div id="gorydetail" style="display:none;">
<h3>PBS in (Some More) Detail: Quorums and Dynamo</h3>

<p>
Many data stores,
including <a href="http://cassandra.apache.org/">Apache
Cassandra</a>, <a href="http://basho.com/">Basho Riak</a>,
and <a href="http://project-voldemort.com/">LinkedIn's Voldemort</a>
adopt
the <a href="www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo
architecture</a> for distributed databases, designed at Amazon.  In
this model, reads and writes are sent to <it>N</it> replicas.  Write
requests complete when <it>W</it> replicas acknowledge the write and
read requests complete when <it>R</it> replicas send a
reply. Dynamo-style quorum replication is eventually consistent; not
all replicas will have all of the same versions at the same time.</p>

<p>
<center>
<img src="dynamo-quorum.png" alt="Dynamo-style quorums" /><br/>
<b>Dynamo-style messaging for a write request where N=3 and W=2.</b>
</center>
</p>

<p>To guarantee consistency, you need overlapping read and write sets,
or quorums.  This is guaranteed when <it>R</it>+<it>W</it> > <it>N</it>
(specifically, when <it>R</it> and <it>W</it> are equal
to <it>ceil(N/2)</it>).  However, waiting for many replies is slow, so
operators frequently choose <it>R</it>+<it>W</it> <= <it>N</it>.</p>

<p>We can model PBS in Dynamo by looking at the probability of quorum
intersection.  We expand prior work on <it>probabilistic quorum
systems</it> to come up with a closed-form solution
for <it>k</it>-staleness in general quorum systems and model message
delays to analyze <it>t</it>-visibility in Dynamo-style systems.  More
details are in the paper, but, in short, as shown below, inconsistency
in Dynamo depends on message reordering.

<p>
<center>
<img src="wars-stale.png" alt="Dynamo-style WARS messaging" /><br />
<b>Dynamo-style data stores deliver inconsistent data when all R of
their read responses were sent by replicas that had not yet received
the last (k) write(s).  The probability of this reordering is
dependent on the latency distributions of the Dynamo protocol, shown
above (W,A,R, and S)</b>
</center>
</p>

</div>

</section>


<section id="instructions">
<div class="page-header"> <h1>Instructions <small>RTFM.</small></h1> </div>
<p>We've implemented a demo of PBS for Dynamo-style quorums below.
The demo is pure client-side Javascript and runs Monte Carlo
simulations in your browser. The main graph displays how long you wait
after a write commits before reading versus the probability of reading
one of the last committed versions.  You can mouse-over the graph to
see the exact probability and play with the controls to explore a
range of configurations.</p>

<p>This demo is strictly for Dynamo-style quorum replication.  If
that's gibberish, goto the <a a href="#about">About</a> section or
read <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-4.pdf">our
technical report</a> or
the <a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo
paper</a>. We don't model read repair or other anti-entropy; these are
rate dependent and result in yet another knob to twiddle (one whose
value you can't likely guarantee).
Read our <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-4.pdf">technical report</a> for more details.</p>

<h3>Controls:</h3>

<ul>
<li><em>Replica Configuration</em>: Controls the number of replicas
contacted for each request (N), the number of responses required
before returning from a read (R) and from a write (W).</li>

<li><em>Tolerable Staleness</em>: How recent does your data need to
be? What's the oldest version you'd like to see? We assume the worst
case, where all the writes finished at the same time.</li>

<li><em>Accuracy</em>: Monte Carlo simulation means we run repeated
trials for a configuration.  While the graph should be monotonic
(increasing everywhere), because of randomness, it may have dips and
spikes; to smooth the curve, increase the number of iterations for
each point on the graph using the slider.</li>

<li><em>Operation Latency</em>: How long does each message take? (We
call this the WARS model in our paper.) Here, each of the four
messages (write request, write ack, read request, read response) is
delayed according to an exponential distribution.  Higher &#x3BB; correspond to a lower mean and tail.

</ul>

<p>
Note that this is a conservative analysis, which means you should see
less staleness in practice.  Also, because we're running Monte Carlo
analysis with (unbounded) exponential messaging delay, we can never
guarantee consistency unless R+W > N, so our maximum confidence (in
the captions) is bounded by the number of iterations you run.
</p>

</section>

<section id="demo">
<div class="page-header"> <h1>How Eventual is Eventual Consistency? <small> PBS in action under Dynamo-style quorums</small> </h1></div>
<center>
  <div id="plot">
  <span class="graph-label">P(Consistency)</span>
  <div id="tcdf" style="width:920px;height:250px;"></div>
    <span class="big-axis-label">Time After Commit (ms)</span><br/>
  </div>
</center>

<p><span id="sweept"></span></p>


<div class="row">
  <div class="span4 show-grid">
    <div id="nrwpanel">
<b>Replica Configuration</b><br/>
<span class="slidewraplt">N:</span> <div class="jqslider" id="n-jsslider"></div><span class="slidewraprt" id="Nslider">3</span><br>
<span class="slidewraplt">R:</span> <div class="jqslider" id="r-jsslider"></div><span class="slidewraprt" id="Rslider">1</span><br>
<span class="slidewraplt">W:</span> <div class="jqslider" id="w-jsslider"></div><span class="slidewraprt" id="Wslider">1</span><br>

</div>
</div>

<div class="span8" id="latencystat">
<div id="statfloat">
Read Latency: Median <span id="rlatency"></span> ms, 99.9th %ile <span id="rlatencypct"></span> ms<br>
Write Latency: Median <span id="wlatency"></span> ms, 99.9th %ile <span id="wlatencypct"></span> ms<br>
</div>
</div>

<div class="span4 show-grid">
    <div id="nrwpanel">
<b>Tolerable Staleness:</b> <span class="slidewrap" id="kslider">1 version</span><br>
<div class="jqsliderbig" id="k-jsslider"></div><br>
<b>Accuracy:</b> <span class="slidewrap" id="itslider">2500</span> iterations/point</br>
 <div class="jqsliderbig" id="it-jsslider"></div><br>
</div>
</div>
</div>

</center>

<script type="text/javascript">

var p = [];

function makeReadSlider(N)
{
    var R = document.getElementById("Rslider").innerHTML; 
    if(R > N)
    {
        R = N;
        document.getElementById("Rslider").innerHTML = R;
    }
   
    jQuery("#r-jsslider").slider({ min: 1, max: N, value: R, change: function(event, ui) { showR(ui.value); }  });
}


function makeWriteSlider(N)
{
    var W = document.getElementById("Wslider").innerHTML;
    if(W > N)
    {
        W = N;
        document.getElementById("Wslider").innerHTML = W;
    }

    jQuery("#w-jsslider").slider({ min: 1, max: N, value: W, change: function(event, ui) { showW(ui.value); }  });
}


  var loaded = false;

    document.observe('dom:loaded', function(){

 

jQuery('#ecbackground-toggle').click(function() {
jQuery('#ecbackground').toggle(200);
 return false;
 });

jQuery('#gorydetail-toggle').click(function() {
jQuery('#gorydetail').toggle(200);
 return false;
 });

    jQuery("#n-jsslider").slider({ min: 1, max: 9, value: 3, change: function(event, ui) { showN(ui.value); }  });
    jQuery("#k-jsslider").slider({ min: 1, max: 9, value: 1, change: function(event, ui) { showK(ui.value); }  });
    jQuery("#it-jsslider").slider({ min: 100, max: 15000, value: 2500, change: function(event, ui) { showIt(ui.value); }  });
    jQuery("#wl-jsslider").slider({ min: 10, max: 1500, value: 100, change: function(event, ui) { editWLambda(ui.value); }  });
    jQuery("#al-jsslider").slider({ min: 10, max: 1500, value: 100, change: function(event, ui) { editALambda(ui.value); }  });
    jQuery("#rl-jsslider").slider({ min: 10, max: 1500, value: 100, change: function(event, ui) { editRLambda(ui.value); }  });
    jQuery("#sl-jsslider").slider({ min: 10, max: 1500, value: 100, change: function(event, ui) { editSLambda(ui.value); }  });

    makeReadSlider(3);
    makeWriteSlider(3);
    editWLambda(100);
    editRLambda(100);
    editALambda(100);
    editSLambda(100);
    updateReadLatency();
    updateWriteLatency();
    loaded = true;
    updateProbability();
		       });

function updateReadLatency()
{
    var N = document.getElementById("Nslider").innerHTML;
    var R = document.getElementById("Rslider").innerHTML;
    var Rl = document.getElementById("rlambda").innerHTML;
    var Sl = document.getElementById("slambda").innerHTML;

    // it's inefficient to do this twice, but the example code suffers otherwise...
    document.getElementById("rlatency").innerHTML = roundNumber(calculate_read_latency(N, R, Rl, Sl, .5),2);
    document.getElementById("rlatencypct").innerHTML = roundNumber(calculate_read_latency(N, R, Rl, Sl, .999),2);
}

function updateWriteLatency()
{
    var N = document.getElementById("Nslider").innerHTML;
    var W = document.getElementById("Wslider").innerHTML;
    var Wl = document.getElementById("wlambda").innerHTML;
    var Al = document.getElementById("alambda").innerHTML;

    document.getElementById("wlatency").innerHTML = roundNumber(calculate_write_latency(N, W, Wl, Al, .5), 2);
    document.getElementById("wlatencypct").innerHTML = roundNumber(calculate_write_latency(N, W, Wl, Al, .999), 2);
}

function updateProbability()
{
    if(!loaded)
        return;

    var N = parseInt(document.getElementById("Nslider").innerHTML);
    var R = parseInt(document.getElementById("Rslider").innerHTML);
    var W = parseInt(document.getElementById("Wslider").innerHTML);
    var k = parseInt(document.getElementById("kslider").innerHTML);
    var Wl = document.getElementById("wlambda").innerHTML;
    var Al = document.getElementById("alambda").innerHTML;
    var Rl = document.getElementById("rlambda").innerHTML;
    var Sl = document.getElementById("slambda").innerHTML;

    var showtimes = [0, 10, 100];
    var st = 0;
    var resultHTML=""

    for(st = 0; st < showtimes.length; st++)
    {
	if(st != 0)
            resultHTML+="<br>"

	var thisps;

        if(R+W<= N)
	{
	    thisps = roundNumber(100*Math.min(MAX_PS,calc_prob_stale(N, R, W, Wl, Al, Rl, Sl, showtimes[st], k)), 2);
	    resultHTML+="You have at least a "+thisps+" percent chance of reading";
	}
	else
	{
	    thisps = 100;
	    resultHTML+="You are guaranteed to read";
        }

        if(k==1)
            resultHTML+=" the last written version";
	else
            resultHTML+=" one of the last "+k+" written versions";

        resultHTML+= " "+showtimes[st]+" ms after";

        if(k==1)
            resultHTML+=" it commits.";
	else
            resultHTML+=" they commit.";
    }

    document.getElementById("sweept").innerHTML = resultHTML;

    var ps_at_five = calc_prob_stale(N, R, W, Wl, Al, Rl, Sl, 5, k);
    var ps_at_ten = calc_prob_stale(N, R, W, Wl, Al, Rl, Sl, 10, k);

    var maxt = 30;
    var step = 2;

    if(ps_at_five > .99)
    {
       maxt = 5;
       step = .5;
    }
    else if(ps_at_ten > .99)
    {
       maxt = 10;
       step = 1;
    }
    p = [];
    for(var ts = 0; ts < maxt; ts+=step)
    { 
        var ps = calc_prob_stale(N, R, W, Wl, Al, Rl, Sl, ts, k);
        p.push([ts, ps]);
        if(ps > .9999 && p.length>5)
            break;
    }

    var f = Flotr.draw(
      $('tcdf'), 
      [ p ],
      {mouse:{
      track: true,
      lineColor: 'blue',
      sensibility: 1, // => The smaller this value, the more precise you've to point
      trackDecimals: 3,
      trackFormatter: function(obj){ return 't = ' + roundNumber(obj.x,2) +', Pr = ' + obj.y; }
      }}
      );
}

function showR(R)
{
    document.getElementById("Rslider").innerHTML=R;
    updateProbability();
    updateReadLatency();
}

function showN(N)
{
    document.getElementById("Nslider").innerHTML=N;
    if(document.getElementById("Rslider").innerHTML > N)
      showR(N);
    if(document.getElementById("Wslider").innerHTML > N)
      showW(N);

    makeReadSlider(N);
    updateReadLatency();

    makeWriteSlider(N);
    updateWriteLatency();
    updateProbability();
}

function showW(W)
{
    document.getElementById("Wslider").innerHTML=W;
    updateProbability();
    updateWriteLatency();
}

function showK(k)
{
    var finalstring = " versions";
    if(k == 1)
      finalstring = " version";
      
    document.getElementById("kslider").innerHTML=k+finalstring;
    updateProbability();
}

function showIt(its)
{
    document.getElementById("itslider").innerHTML=its;
    update_max_iterations(its);
    updateProbability();
}

function showT(t)
{
   document.getElementById("tslider").innerHTML=t;
   updateProbability();
}

function editLambda(lmbda, eleid, elecontainer)
{
	document.getElementById(eleid).innerHTML=(lmbda/1000).toFixed(3);
        var d1 = [];
        //for(var i = 0; i < Math.min(20000/lmbda, 300); i += 0.5)
	for(var i = 0; i < 32; i += 0.5)
		       d1.push([i, calc_exponential_cdf(lmbda/1000, i)]);
		   
		   var f = Flotr.draw($(elecontainer), [ d1 ], {xaxis: { tickDecimals: 0 }});
        updateProbability();
}


function editWLambda(wlambda)
{
        editLambda(wlambda, "wlambda", "wcontainer");
	updateWriteLatency();
}

function editALambda(alambda)
{
        editLambda(alambda, "alambda", "acontainer");
	updateWriteLatency();
}

function editRLambda(rlambda)
{
        editLambda(rlambda, "rlambda", "rcontainer");
	updateReadLatency();
}

function editSLambda(slambda)
{
        editLambda(slambda, "slambda", "scontainer");
	updateReadLatency();
}

</script>

<div id="latencypanel" class="span16 show-grid">
<b>Operation Latency</b>: Exponentially Distributed CDFs

<div class="row">
<div class="span4">
  <center>
    <span class="graph-label">W: Write Request to Replica</span>
    <div id="wcontainer" style="width:180px;height:100px;"></div>
    <span class="axis-label">Latency (ms)</span><br/>
    <span class="lambdalabel">&#x3BB;</span> <div class="lmbda-jqslider" id="wl-jsslider"></div><span id="wlambda">.100</span><br>
  </center>
</div>

<div class="span4">
  <center>
    <span class="graph-label">A: Replica Write Ack</span>
    <div id="acontainer" style="width:180px;height:100px;"></div>
    <span class="axis-label">Latency (ms)</span><br/>
    <span class="lambdalabel">&#x3BB;</span> <div class="lmbda-jqslider" id="al-jsslider"></div><span id="alambda">.100</span><br>
  </center>
</div>

<div class="span4">
  <center>
    <span class="graph-label">R: Read Request to Replica</span>
    <div id="rcontainer" style="width:180px;height:100px;"></div>
    <span class="axis-label">Latency (ms)</span><br/>
    <span class="lambdalabel">&#x3BB;</span> <div class="lmbda-jqslider" id="rl-jsslider"></div><span id="rlambda">.100</span><br>
  </center>
</div>

<div class="span4">
  <center>
    <span class="graph-label">S: Replica Read Response</span>
    <div id="scontainer" style="width:180px;height:100px;"></div>
    <span class="axis-label">Latency (ms)</span><br/>
    <span class="lambdalabel">&#x3BB;</span> <div class="lmbda-jqslider" id="sl-jsslider"></div><span id="slambda">.100</span><br>
  </center>
</div>
</div>

</section>

<section id="questions">
<div class="page-header"> <h1>Questions <small> and some answers. But you should really just read our paper instead.</small> </h1> </div>

<p>Most of your questions about the simulation will probably be answered in the <a href="#instructions">instructions</a> section.</p>

<p>If you're interested in tons more technical detail, read
our <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-4.pdf">technical report</a>.  It's not possible to
cover as much detail on a single site without regurgitating the paper,
plus paper reading is good for you.</p>

<p><b>How can I use PBS with my data store?</b> <br/> PBS requires
modeling read and write propagation to and from replicas. If you can
measure the write propagation delays (and read messaging delays), you
can predict the consistency provided by your data store.  We've
analyzed Dynamo-style systems here and in our paper because they're
widely deployed (and poorly understood).  We have successfully
modified Cassandra to provide PBS predictions with high accuracy
(within .02%).  If you want to implement PBS for your data store, we
should talk.</p>

<p><b>Can you model {read-repair, other anti-entropy, less
conservative analyses, some other latency distribution}?</b> <br/> You
bet! PBS is generic, but this demo simulation is intentionally simple
to make it easier to play with.  In our paper, we're conservative
(understating staleness instead of overstating it, when the choice
arises).  In general, conservative figures are more broadly
applicable.  However, it's easy to accommodate these features, and, if
you're interested, we should talk.  We have some real-world latency
distributions in our paper, but you can use whatever you like with
PBS.</p>

<p><b>Should I use an eventually consistent data store?</b> <br/>Consistency requirements vary from application to application.  PBS is intended as a
descriptive tool for determining the consistency provided by
eventually consistent data stores but may strengthen the case for using
eventual consistency in practice.</p>

</section>


<section id="moreinfo">
<div class="page-header"> <h1>More Info <small>Awesome! What next?</small></h1> </div>

<p>PBS was developed at UC Berkeley.  The PBS team is 
<a href="http://bailis.org" target="_blank">Peter Bailis</a>,
<a href="http://shivaram.info/" target="_blank">Shivaram Venkataraman</a>,
<a href="http://db.cs.berkeley.edu/~jmh/" target="_blank">Joe Hellerstein</a>,
<a href="http://www.cs.berkeley.edu/~franklin/" target="_blank">Mike Franklin</a>, and
<a href="http://www.cs.berkeley.edu/~istoica/" target="_blank">Ion Stoica</a>. 


<p>Our paper on PBS detailing precise semantics
for <i>k</i>-staleness, <i>t</i>-staleness, and <<i>k,t</i>>-staleness
is currently under peer review.<br>In the meantime, we've provided a
<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2012/EECS-2012-4.pdf">technical
report</a> for your convenience.</p>

<p>The <a href="calculate-examples.js" target="_blank">Javascript
implementation</a> of the PBS Monte Carlo analysis used on this page
is pretty short and well-commented.  The code is not too difficult,
and we welcome any improvements. (Yes, we too think Javascript is
ugly.)  We have a patch (read: hack) for Cassandra to gather WARS that's available
upon request.</p>

<p>If you have any questions or want to talk about PBS, please feel
  free to send us a <a href="http://twitter.com/pbailis"
  target="_blank">tweet</a> or drop us a line at <SCRIPT TYPE="text/javascript">
// protected email script by Joe Maller
// JavaScripts available at http://www.joemaller.com
// this script is free to use and distribute
// but please credit me and/or link to my site

emailE=('pbailis@' + 'cs.berkeley.edu')
document.write('<A href="mailto:' + emailE +'">' + emailE +'</a>')

</script>

<NOSCRIPT>
    <em>Email address protected by JavaScript.<BR>
    Please enable JavaScript to contact me.</em>
</NOSCRIPT>.</p>

<p>We're super excited about real people and real problems.  Again, if you or
your organization want to talk, let us know. Bay Area travel is easy.</p>

</section>

<section id="thanks">
<div class="page-header"> <h1>Acknowledgments <small>Wu-tang is for the children</small></h1></div>

<div id="acks">
<p>Many kind folks provided useful feedback on our work, including
<a href="http://research.microsoft.com/en-us/people/aguilera/" target="_blank">Marcos Aguilera</a>, 
<a href="http://www.cs.berkeley.edu/~palvaro/" target="_blank">Peter Alvaro</a>, 
<a href="http://www.cs.berkeley.edu/~brewer/" target="_blank">Eric Brewer</a>,
<a href="http://www.neilconway.org/" target="_blank">Neil Conway</a>,
<a href="http://www.eecs.berkeley.edu/~gdurrett/" target="_blank">Greg Durrett</a>,
<a href="https://twitter.com/#!/strlen" target="_blank">Alex Feinberg</a>,
<a href="http://www.sics.se/~ali/" target="_blank">Ali Ghodsi</a>,
<a href="http://www.cs.berkeley.edu/~haryadi/" target="_blank">Hariyadi Gunawi</a>,
<a href="http://codahale.com/" target="_blank">Coda Hale</a>,
<a href="http://www.eecs.harvard.edu/~bkate/" target="_blank">Bryan Kate</a>,
<a href="http://db.csail.mit.edu/madden/" target="_blank">Sam Madden</a>,
<a href="http://www.eecs.berkeley.edu/~wrm/" target="_blank">Bill Marczak</a>,
<a href="https://twitter.com/#!/kayousterhout" target="_blank">Kay Ousterhout</a>,
<a href="http://pages.cs.wisc.edu/~chrisre/" target="_blank">Christopher Re</a>,
<a href="http://www.eecs.berkeley.edu/Faculty/Homepages/shenker.html" target="_blank">Scott Shenker</a>,
<a href="http://www.malhar.net/sriram/" target="_blank">Sriram Srinivasan</a>,
<a href="http://research.microsoft.com/en-us/people/terry/" target="_blank">Doug Terry</a>,
<a href="http://www.cs.berkeley.edu/~gvaliant/" target="_blank">Greg Valiant</a>, and 
<a href="http://www.eecs.berkeley.edu/~pwendell/"
target="_blank">Patrick Wendell</a>.  This acknowledgement does not
imply any sort of endorsement--merely a thank-you.  Any errors or
inaccuracies are attributable to the authors alone.</p>

<p>This work was supported in part
by <a href="http://amplab.cs.berkeley.edu/">AMPLab</a> gifts from
Google, SAP, Amazon Web Services, Blue Goji, Cloudera, Ericsson,
General Electric, Hewlett Packard, Huawei, IBM, Intel, MarkLogic,
Microsoft, NEC Labs, NetApp, Oracle, Quanta, Splunk, VMware and by
DARPA (contract #FA8650-11-C-7136).

This material is based upon work supported by the National Science
Foundation Graduate Research Fellowship under Grant No. DGE
1106400.</p>
</div>
</section>



    <footer class="footer">
      <div class="container">
        <p class="pull-right"><a href="#">Back to top</a></p>
        <p>
	  This page's design and layout were shamelessly cobbled together
          using <a href="http://twitter.github.com/bootstrap/" target="_blank">Bootstrap</a>
          and its provided sample
          code.  <a href="http://solutoire.com/flotr/" target="_blank">Flotr</a>
          powers the graph visualization with
          some <a href="http://jqueryui.com/" target="_blank">jQuery UI</a> thrown in
          for good measure.  This page was built by <a href="http://bailis.org/"
          target="_blank">Peter Bailis</a>
          (<a href="http://twitter.com/pbailis"
          target="_blank">@pbailis</a>) and the PBS team<br />.
        </p>
      </div>
    </footer>


</body>
